<!DOCTYPE html>

<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
<head>
<title>Algorithm</title>
<meta name="description" content="Algorithm">
<meta name="keywords" content="book">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">

<meta charset="utf-8">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var math_displays = document.getElementsByClassName("math-display");
        for (var i = 0; i < math_displays.length; i++) {
            katex.render(math_displays[i].textContent, math_displays[i], { displayMode: true, throwOnError: false });
        }
        var math_inlines = document.getElementsByClassName("math-inline");
        for (var i = 0; i < math_inlines.length; i++) {
            katex.render(math_inlines[i].textContent, math_inlines[i], { displayMode: false, throwOnError: false });
        }
    });
</script>
<style>
    .navigate {
        background-color: #f0f0f0;
        border: 1px;
        color: black;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 8px;
    }
</style>
<link rel="next" href="node246.html">
<link rel="previous" href="node244.html">
<link rel="up" href="node244.html">
<link rel="next" href="node246.html">
</head>

<body>
<!--Navigation Panel-->
<a name="tex2html4506"
  href="node246.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html4500"
  href="node244.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html4494"
  href="node244.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html4502"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html4504"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b> Next:</b> <a name="tex2html4507"
  href="node246.html">Convergence Properties</a>
<b> Up:</b> <a name="tex2html4501"
  href="node244.html">Lanczos Method &nbsp; Z.&nbsp;Bai</a>
<b> Previous:</b> <a name="tex2html4495"
  href="node244.html">Lanczos Method &nbsp; Z.&nbsp;Bai</a>
 &nbsp <b>  <a name="tex2html4503"
  href="node5.html">Contents</a></b> 
 &nbsp <b>  <a name="tex2html4505"
  href="node422.html">Index</a></b> 
<br>
<br>
<!--End of Navigation Panel--><h2><a name="SECTION001681000000000000000"></a> <a name="zbdd:algorithm"></a>
<br>
算法
</h2>

<p>
非厄米特兰索兹方法，如算法<a href="node245.html#bd:lanalg">7.13</a>所示，是一种双侧迭代算法，起始向量为<span class="math-inline">p_1</span>和<span class="math-inline">q_1</span>。它可以被视为通过双侧格拉姆-施密特过程对两个克雷洛夫序列进行双正交化：
<br><p></p>
<div align="center">


<div class="math-display">\{ q_1, Aq_1, A^2q_1, \ldots \} \quad \mathrm{和} \quad \{ p_1, A^{\ast}p_1, (A^{\ast})^2 p_1, \ldots \}.</div>
</div>
<br clear="ALL">
<p></p>
生成的两个向量序列<span class="math-inline">\{q_i\}</span>和<span class="math-inline">\{p_i\}</span>使用三项递归公式：
<br>
<div align="center"><a name="right_recursion"></a><a name="left_recursion"></a>

<table align="center" cellpadding="0" width="100%">
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle \beta_{j+1} q_{j+1}</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle Aq_j - \alpha_j q_j - \gamma_j q_{j-1},</span></td>
<td width=10 align="right">
(139)</td></tr>
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle \bar{\gamma}_{j+1} p_{j+1}</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle A^{\ast} p_j - \bar{\alpha}_j p_j - \bar{\beta}_j p_{j-1}.</span></td>
<td width=10 align="right">
(140)</td></tr>
</table></div>
<br clear="ALL"><p></p>
向量<span class="math-inline">\{q_i\}</span>和<span class="math-inline">\{p_i\}</span>被称为<em>兰索兹向量</em>，分别张成<span class="math-inline">{\mathcal K}^j(A, q_1)</span>和<span class="math-inline">{\mathcal K}^j(A^{\ast}, p_1)</span>，并且是双正交的，即<span class="math-inline">p^{\ast}_{k} q_{\ell} = 0</span>如果<span class="math-inline">k \neq \ell</span>，以及<span class="math-inline">w^{\ast}_{k} v_{k} = 1</span>。在矩阵表示中，第<span class="math-inline">j</span>步，兰索兹方法生成两个<span class="math-inline">n \times j</span>矩阵<span class="math-inline">Q_j</span>和<span class="math-inline">P_j</span>：
<br><p></p>
<div align="center">


<div class="math-display">Q_j = [ q_1, q_2, \ldots, q_j ], \quad P_j = [ p_1, p_2, \ldots, p_j ]</div>
</div>
<br clear="ALL">
<p></p>
以及
<br><p></p>
<div align="center">


<div class="math-display">t_j = \left[ \begin{array}{ccccc} \alpha_1 & \gamma_2 & & & \\ \vdots & \ddots & \ddots & & \\ & \gamma_{j-1} & \alpha_{j-1} & \gamma_j & \\ & & \beta_j & \alpha_j \\ \end{array} \right].</div>
</div>
<br clear="ALL">
<p></p>
计算的量满足称为<em>兰索兹分解</em>的控制关系：
<br>
<div align="center"><a name="rightgoverneq"></a><a name="leftgoverneq"></a><a name="biorthogonal"></a>

<table align="center" cellpadding="0" width="100%">
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle AQ_j</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle Q_j T_j + \beta_{j+1} q_{j+1} e_{j}^{\ast},</span></td>
<td width=10 align="right">
(141)</td></tr>
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle A^{\ast} P_j</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle P_j T_j^{\ast} + \bar{\gamma}_{j+1} p_{j+1} e_j^{\ast},</span></td>
<td width=10 align="right">
(142)</td></tr>
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle P_j^{\ast} Q_j</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle I_j.</span></td>
<td width=10 align="right">
(143)</td></tr>
</table></div>
<br clear="ALL"><p></p>
此外，<span class="math-inline">P_j^{\ast} q_{j+1} = 0</span>和<span class="math-inline">p_{j+1}^{\ast} Q_j = 0</span>。关系式(<a href="node245.html#biorthogonal">7.37</a>)表明兰索兹向量（基）是双正交的。但请注意，<span class="math-inline">Q_j</span>和<span class="math-inline">P_j</span>都不是酉矩阵。在兰索兹基中，矩阵<span class="math-inline">A</span>由一个非厄米特三对角矩阵表示，
<br>
<div align="right">


<table width="100%" align="center">
<tr valign="middle"><td align="center" NOWRAP><a name="nstridia"></a><div class="math-display">P_j^{\ast} AQ_j = T_j.</div></td>
<td width=10 align="right">
(144)</td></tr>
</table>
<br clear="ALL"></div><p></p>
在任何步骤<span class="math-inline">j</span>，我们可以计算<span class="math-inline">T_j</span>的特征解，
<br><p></p>
<div align="center">


<div class="math-display">T_j z_i^{(j)} = \theta_i^{(j)} z_i^{(j)} \quad \mathrm{和} \quad (w_i^{(j)})^{\ast} T_j = \theta_i^{(j)} (w_i^{(j)})^{\ast}.</div>
</div>
<br clear="ALL">
<p></p>
矩阵<span class="math-inline">A</span>的特征值由<span class="math-inline">T_j</span>的特征值<span class="math-inline">\theta_i^{(j)}</span>近似，这些特征值被称为里兹值。

<p>
对于每个里兹值<span class="math-inline">\theta_i^{(j)}</span>，存在相应的右和左里兹向量，
<br>
<div align="right">


<table width="100%" align="center">
<tr valign="middle"><td align="center" NOWRAP><a name="ritz_vectors"></a><div class="math-display">x_i^{(j)} = Q_j z_i^{(j)} \quad \mathrm{和} \quad y_i^{(j)} = P_j w_i^{(j)}.</div></td>
<td width=10 align="right">
(145)</td></tr>
</table>
<br clear="ALL"></div><p></p>
里兹值和向量的收敛性可以通过比较残差的范数与<span class="math-inline">x_i^{(j)}</span>和<span class="math-inline">y_i^{(j)}</span>的范数来评估，
<br>
<div align="center"><a name="bnhlrr"></a><a name="bnhllr"></a>

<table align="center" cellpadding="0" width="100%">
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle r_i^{(j)}</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle Ax_i^{(j)} - \theta_i^{(j)} x_i^{(j)},</span></td>
<td width=10 align="right">
(146)</td></tr>
<tr valign="middle"><td NOWRAP align="right"><span class="math-inline">\displaystyle (s_i^{(j)})^{\ast}</span></td>
<td align="center" NOWRAP><span class="math-inline">\textstyle =</span></td>
<td align="left" NOWRAP><span class="math-inline">\displaystyle (y_i^{(j)})^{\ast} A - \theta_i^{(j)} (y_i^{(j)})^{\ast}</span></td>
<td width=10 align="right">
(147)</td></tr>
</table></div>
<br clear="ALL"><p></p>
此外，根据方程(<a href="node245.html#rightgoverneq">7.35</a>)，右残差向量变为
<br>
<div align="right">


<table width="100%" align="center">
<tr valign="middle"><td align="center" NOWRAP><a name="bnhlrr2"></a><div class="math-display">r_i^{(j)} = \beta_{j+1} q_{j+1} (e_j^{\ast} z_i^{(j)}),</div></td>
<td width=10 align="right">
(148)</td></tr>
</table>
<br clear="ALL"></div><p></p>
根据方程(<a href="node245.html#leftgoverneq">7.36</a>)，左残差向量变为
<br>
<div align="right">


<table width="100%" align="center">
<tr valign="middle"><td align="center" NOWRAP><a name="bnhllr2"></a><div class="math-display">(s_i^{(j)})^{\ast} = \gamma_{j+1} p_{j+1}^{\ast} ((w_i^{(j)})^{\ast} e_j).</div></td>
<td width=10 align="right">
(149)</td></tr>
</table>
<br clear="ALL"></div><p></p>
因此，与厄米特情况（参见第<a href="node103.html#sec:lan">4.4</a>节）一样，残差范数可以在不显式计算里兹向量<span class="math-inline">x_i^{(j)}</span>和<span class="math-inline">y_i^{(j)}</span>的情况下获得，尽管<span class="math-inline">\Vert x_i^{(j)} \Vert _2</span>和<span class="math-inline">\Vert y_i^{(j)} \Vert _2</span>是不可用的。有关此主题的更详细讨论，请参见第<a href="node246.html#zbdd:convergence">7.8.2</a>节。

<p>
<br>
<a name="bd:lanalg"></a><IMG
 width="598" height="497" align="bottom" border="0"
 src="img2199.png"
 alt="\begin{algorithm}{Lanczos Method for NHEP
}
{
\begin{tabbing}
(nr)ss\=ijkl\=bbb...
...ximate eigenvectors <span class="math-inline">x^{(j)}_i</span>\ and <span class="math-inline">y^{(j)}_i</span>\end{tabbing}
}
\end{algorithm}">
<br> 

<p>
我们现在对算法<a href="node245.html#bd:lanalg">7.13</a>的某些步骤进行评论：
<dl>
<dt><strong>(1)</strong></dt>
<dd>初始起始向量<span class="math-inline">p_1</span>和<span class="math-inline">q_1</span>最好由用户根据关于<span class="math-inline">A</span>所需特征向量的任何可用知识来选择。在没有此类知识的情况下，可以选择具有随机分布条目的<span class="math-inline">q_1</span>，并让<span class="math-inline">p_1 = q_1</span>。

<p>
</dd>
<dt><strong>(2), (3), (18), (19)</strong></dt>
<dd>在这些步骤中需要矩阵-向量乘法例程来乘以<span class="math-inline">A</span>和<span class="math-inline">A^{\ast}</span>与任意向量。这通常是计算瓶颈。有关移位-反演情况下的实现注释，请参见下面的收敛性讨论。

<p>
</dd>
<dt><strong>(8)</strong></dt>
<dd>这是方法可能崩溃的两种情况之一。实际上，这是一种理想的崩溃。如果<span class="math-inline">r</span>为零，则兰索兹向量<span class="math-inline">\{q_1, q_2, \ldots, q_j\}</span>张成<span class="math-inline">A</span>的一个（右）不变子空间；每个里兹值和相应的右里兹向量是<span class="math-inline">A</span>的精确特征值和特征向量。如果需要，可以通过选择任何满足<span class="math-inline">P_j^{\ast} q_{j+1} = 0</span>的向量<span class="math-inline">q_{j+1}</span>并设置<span class="math-inline">\beta_{j+1} = 0</span>来继续兰索兹算法。当<span class="math-inline">s</span>或<span class="math-inline">r</span>和<span class="math-inline">s</span>都消失时，可以采取类似的行动。

<p>
在实践中，精确的零向量是罕见的。<span class="math-inline">r</span>和/或<span class="math-inline">s</span>的范数可能会变得非常小。应给出一个容差值来检测相对于<span class="math-inline">\Vert Q \Vert _2 \Vert T \Vert _2</span>或<span class="math-inline">\Vert P \Vert _2 \Vert T \Vert _2</span>的微小<span class="math-inline">\Vert r \Vert _2</span>，或相对于<span class="math-inline">\Vert s \Vert _2</span>的微小<span class="math-inline">\Vert s \Vert _2</span>。默认容差值是机器精度<span class="math-inline">\epsilon</span>的小倍数。

<p>
</dd>
<dt><strong>(10)</strong></dt>
<dd>如果<span class="math-inline">\omega_j = r^{\ast} s = 0</span>在<span class="math-inline">r</span>或<span class="math-inline">s</span>消失之前，方法会发生本质崩溃。在大多数情况下，我们可以继续在克雷洛夫子空间<span class="math-inline">{\mathcal K}^{j+k}(A, r)</span>和<span class="math-inline">{\mathcal K}^{j+k}(A^{\ast}, s)</span>中寻找新向量，对于某个整数<span class="math-inline">k > 0</span>，并在<span class="math-inline">T_j</span>的三对角线之外添加一个块；这种所谓的向前看过程在[<a href="node421.html#frgn93">178</a>]中描述，并在QMRPACK中实现（参见第<a href="node248.html#subsec:nsymlansoftware">7.8.3</a>节）。然而，如果我们的起始向量<span class="math-inline">q_1</span>和<span class="math-inline">p_1</span>具有不同的最小多项式（或者，例如，<span class="math-inline">p_1</span>和<span class="math-inline">q_1</span>是不同特征向量集的复合），即使这也不起作用，我们会有一个<i>不匹配</i>，也称为<em>不可治愈的崩溃</em>。参见[<a href="node421.html#parl92">354</a>]进一步讨论。另一种处理崩溃的方法在第<a href="node250.html#sec:nsymblocklanczos">7.9</a>节中讨论。

<p>
在实践中，精确的崩溃是罕见的。接近崩溃的情况更常见；即，<span class="math-inline">\omega_j</span>是非零但绝对值极小。接近崩溃会导致停滞和不稳定。检测接近崩溃的任何标准要么在某些情况下停止得太早，要么在其他情况下停止得太晚。检测特征值问题中接近崩溃的合理折衷标准是，如果<span class="math-inline">\vert \omega_j \vert \leq \sqrt{\epsilon} \Vert r \Vert _2 \Vert s \Vert _2</span>，则停止。

<p>
</dd>
<dt><strong>(15)</strong></dt>
<dd>通过QR算法计算三对角矩阵<span class="math-inline">T_j</span>的特征分解（参见第<a href="node209.html#sec:nsymeigdirect">7.3</a>节）的成本大约是每迭代<span class="math-inline">30j^3</span>次浮点运算，累积成本从步骤1到<span class="math-inline">j</span>是<span class="math-inline">15j^4</span>次浮点运算。定期解决特征问题，例如每10步一次，可以降低这一成本。

<p>
尚未发现任何稳定的算法可以在<span class="math-inline">j^2</span>次浮点运算中近似一般三对角矩阵的特征值，尽管最近提出了条件稳定的算法，如[<a href="node421.html#cuwi96">94</a>,<a href="node421.html#watk99">189</a>]。据作者所知，没有兰索兹算法的软件实现采用快速条件稳定特征求解器。

<p>
</dd>
<dt><strong>(16)</strong></dt>
<dd>一旦确定了基<span class="math-inline">Q_j</span>和<span class="math-inline">P_j</span>，使得<span class="math-inline">T_j</span>的特征值<span class="math-inline">\theta_i^{(j)}</span>（参见(<a href="node245.html#nstridia">7.38</a>)）近似于<span class="math-inline">A</span>的所有所需特征值，且残差足够小，计算就会停止，这些残差根据方程(<a href="node245.html#bnhlrr2">7.42</a>)和(<a href="node245.html#bnhllr2">7.43</a>)计算。收敛性在第<a href="node246.html#zbdd:convergence">7.8.2</a>节中有更详细的讨论。

<p>
如果没有重新双正交化（参见[<a href="node421.html#day97">105</a>]），那么在有限精度算术中，一旦里兹值收敛到<span class="math-inline">A</span>的一个特征值，这个里兹值将在后续的兰索兹步骤中出现副本。例如，减少的三对角矩阵<span class="math-inline">T_j</span>的一组里兹值可能近似于原始矩阵<span class="math-inline">A</span>的一个单一特征值。伪值[<a href="node421.html#cuwi86">93</a>]是一个简单的里兹值，也是从<span class="math-inline">T_j</span>中删除第一行和第一列得到的<span class="math-inline">j-1</span>阶矩阵的特征值。这样的伪值应从考虑中剔除。<span class="math-inline">T_j</span>的特征值，如果不是伪值，则被识别为原始矩阵<span class="math-inline">A</span>的特征值的近似值，并进行收敛性测试。

<p>
</dd>
<dt><strong>(17)</strong></dt>
<dd>与厄米特情况一样，在有限精度算术的存在下，计算的兰索兹向量<span class="math-inline">\{q_i\}</span>和<span class="math-inline">\{p_i\}</span>的双正交性会恶化。可以使用双侧修正格拉姆-施密特（TSMGS）过程[<a href="node421.html#parl92">354</a>]来重新双正交化第<span class="math-inline">(j+1)</span>个兰索兹向量；

<p>
for <span class="math-inline">i=1,2,\ldots,j</span>
<br><span class="math-inline">q_{j+1} = q_{j+1} - q_i (p_i^{\ast} q_{j+1})</span>
<br><span class="math-inline">p_{j+1} = p_{j+1} - p_i (q_i^{\ast} p_{j+1})</span>
<br>
end for

<p>
在每一步应用TSMGS过程非常耗时，并成为计算瓶颈。在[<a href="node421.html#day97">105</a>]中，提出了一个有效的替代方案。这一主题在第<a href="node250.html#sec:nsymblocklanczos">7.9</a>节中重新讨论。
</dd>
</dl>

<p>
<hr><!--Navigation Panel-->
<a name="tex2html4506"
  href="node246.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html4500"
  href="node244.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html4494"
  href="node244.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html4502"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html4504"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b> Next:</b> <a name="tex2html4507"
  href="node246.html">Convergence Properties</a>
<b> Up:</b> <a name="tex2html4501"
  href="node244.html">Lanczos Method &nbsp; Z.&nbsp;Bai</a>
<b> Previous:</b> <a name="tex2html4495"
  href="node244.html">Lanczos Method &nbsp; Z.&nbsp;Bai</a>
 &nbsp <b>  <a name="tex2html4503"
  href="node5.html">Contents</a></b> 
 &nbsp <b>  <a name="tex2html4505"
  href="node422.html">Index</a></b> 
<!--End of Navigation Panel-->
<address>
Susan Blackford
2000-11-20
</address>
</body>
</html>
