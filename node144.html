<!DOCTYPE html>

<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
<head>
<title>An Algorithm Template.</title>
<meta charset="utf-8">
<meta name="description" content="An Algorithm Template.">
<meta name="keywords" content="book, math, eigenvalue, eigenvector, linear algebra, sparse matrix">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var math_displays = document.getElementsByClassName("math-display");
        for (var i = 0; i < math_displays.length; i++) {
            katex.render(math_displays[i].textContent, math_displays[i], { displayMode: true, throwOnError: false });
        }
        var math_inlines = document.getElementsByClassName("math-inline");
        for (var i = 0; i < math_inlines.length; i++) {
            katex.render(math_inlines[i].textContent, math_inlines[i], { displayMode: false, throwOnError: false });
        }
    });
</script>
<style>
    .navigate {
        background-color: #ffffff;
        border: 1px solid black;
        color: black;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 18px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 4px;
    }
    .crossref {
        width: 10pt;
        height: 10pt;
        border: 1px solid black;
        padding: 0;
    }
    .footnote {
        width: 10pt;
        height: 10pt;
        border: 1px solid black;
        padding: 0;
        transform: rotate(45deg);
    }
</style>
</head>

<body >
<!--Navigation Panel-->
<a name="tex2html2912"
  href="node145.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html2906"
  href="node140.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html2902"
  href="node143.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html2908"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html2910"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b>下一节：</b><a name="tex2html2913" href="node145.html">计算内部特征值</a>
<b>上一级：</b><a name="tex2html2907" href="node140.html">重启与收缩</a>
<b>上一节：</b><a name="tex2html2903" href="node143.html">Preconditioning.</a>
  
  
<br>
<br>
<!--End of Navigation Panel--><h4><a name="SECTION001373040000000000000">
算法模板</a>
</h4> 
包含重启机制和收缩技术以计算多个特征对（eigenpairs）的完整Jacobi-Davidson方法被称为JDQR[<a href="node421.html#fosv98">172</a>]，因为它可以被视为QR算法的一种迭代方法。该算法的模板在算法<a href="node144.html#alg:jdqr">4.17</a>中给出。

<p>
<br>
<a name="alg:jdqr"></a><img
 width="598" height="728" align="BOTTOM" border="0"
 src="img1365.png"
 alt="\begin{algorithm}{Jacobi--Davidson Method for <span class="math-inline">{k}_{\max}</span>\ Exterior
Eigenvalues...
...st}){t} = -r<span class="math-inline">\ \\
{\rm (32)} \&gt; {\bf end while}
\end{tabbing}}
\end{algorithm}">
<br>

<p>
要应用此算法，我们需要指定初始向量</span>{v}_0<span class="math-inline">、容差</span>\epsilon<span class="math-inline">、目标值</span>\tau<span class="math-inline">以及指定应计算多少个接近</span>\tau<span class="math-inline">的特征对的数值</span>{k}_{\max}<span class="math-inline">。</span>{m}_{\max}<span class="math-inline">表示搜索子空间的最大维度。如果超过此值，将使用指定维度</span>{m}_{\min}<span class="math-inline">的子空间进行重启。

<p>
通常，当</span>\tau<span class="math-inline">选择大于</span>\lambda_{\max}(A)<span class="math-inline">时，算法会输出</span>{k}_{\max}<span class="math-inline">个最大特征值；当</span>\tau<span class="math-inline">选择小于</span>\lambda_{\min}(A)<span class="math-inline">时，则会输出</span>{k}_{\max}<span class="math-inline">个最小特征值。计算得到的特征对</span>(\widetilde\lambda_j,\widetilde{x}_{j})<span class="math-inline">，满足</span>\Vert\widetilde{x}_{j}\Vert _2=1<span class="math-inline">，满足</span>\Vert A \widetilde{x}_{j}-\widetilde\lambda_j\widetilde{x}_{j}\Vert _2\leq j\epsilon<span class="math-inline">，其中</span>\widetilde{x}_j<span class="math-inline">表示</span>\widetilde{X}<span class="math-inline">的第</span>j<span class="math-inline">列。

<p>
原则上，该算法计算最接近指定目标值</span>\tau<span class="math-inline">的</span>{k}_{\max}<span class="math-inline">个特征值。这仅在需要</span>{k}_{\max}<span class="math-inline">个最大或最小特征值时可靠。对于内部特征值集，我们将在第<a href="node145.html#sec:jdhar">4.7.4</a>节中描述更安全的技术。现在，我们将根据前几节的讨论，对算法的一些部分进行评论。

<p>
<dl>
<dt><strong>(2)</strong></dt>
<dd>初始化阶段。搜索子空间以</span>t=v_0<span class="math-inline">初始化。

<p>
</dd>
<dt><strong>(4)-(6)</strong></dt>
<dd>搜索子空间的新扩展向量通过修正的Gram-Schmidt方法与当前搜索子空间正交化。为了提高数值稳定性，可以使用算法<a href="node138.html#alg:rgs">4.14</a>中给出的模板进行替换。

<p>
如果</span>{m}=0<span class="math-inline">，这是一个空循环。

<p>
</dd>
<dt><strong>(8)-(10)</strong></dt>
<dd>我们仅计算厄米矩阵</span>{M}\equiv V^\ast AV<span class="math-inline">（阶数为</span>{m}<span class="math-inline">）的上三角部分。

<p>
</dd>
<dt><strong>(11)</strong></dt>
<dd>对于</span>{m}<span class="math-inline">阶矩阵</span>{M}<span class="math-inline">的特征问题，可以使用LAPACK中的标准稠密厄米特征问题求解器来解决。我们选择计算标准Ritz值，这使得算法适合于计算</span>A<span class="math-inline">的最大或最小</span>{k}_{\max}<span class="math-inline">个特征值。如果希望计算谱内部某处的</span>{k}_{\max}<span class="math-inline">个特征值，建议使用谐波Ritz值；参见第<a href="node145.html#sec:jdhar">4.7.4</a>节。

<p>
矩阵</span>{V}<span class="math-inline">表示列向量为</span>{v}_j<span class="math-inline">的</span>n<span class="math-inline">阶</span>{m}<span class="math-inline">矩阵，</span>{V^A}\equiv AV<span class="math-inline">亦然；</span>S<span class="math-inline">是列向量为</span>s_j<span class="math-inline">的</span>{m}<span class="math-inline">阶矩阵，</span>\Theta = \diag(\theta_1,\ldots,\theta_m)<span class="math-inline">。

<p>
</dd>
<dt><strong>(13)</strong></dt>
<dd>停止准则是在归一化特征向量近似的残差范数低于</span>\epsilon<span class="math-inline">时接受该近似。这意味着我们接受特征值计算中的误差约为</span>\epsilon^2<span class="math-inline">，特征向量中的角度误差约为</span>\epsilon<span class="math-inline">，前提是相关特征值是简单且与其他特征值充分分离的；参见（<a href="node86.html#eigvecpert">4.4</a>）。

<p>
偶尔，</span>A<span class="math-inline">的某个所需特征向量可能未被检测到，例如，如果</span>v_0<span class="math-inline">在相应特征向量方向上没有分量。对于随机初始向量，这种情况不太可能发生。（参见算法<a href="node138.html#alg:jd">4.13</a>的注释(14)。）

<p>
</dd>
<dt><strong>(16)</strong></dt>
<dd>在接受一个Ritz对后，我们继续搜索下一个特征对，剩余的Ritz向量作为初始搜索空间的基础。这些向量在(17)-(20)中计算。

<p>
</dd>
<dt><strong>(23)</strong></dt>
<dd>一旦当前特征向量的搜索空间维度超过</span>{m}_{\max}<span class="math-inline">，我们就重启。重启过程使用与目标值</span>\tau<span class="math-inline">最接近的</span>{m}_{\min}<span class="math-inline">个Ritz向量所张成的子空间（这些向量在(25)-(27)行中计算）。

<p>
</dd>
<dt><strong>(30)-(31)</strong></dt>
<dd>我们将已锁定的（已计算的）特征向量收集在</span>\widetilde{X}<span class="math-inline">中，矩阵</span>\widetilde{Q}<span class="math-inline">是</span>\widetilde{X}<span class="math-inline">扩展了当前特征向量近似</span>{u}<span class="math-inline">。这样做是为了获得更紧凑的表达形式；修正方程等价于（<a href="node142.html#eq:jddefl">4.50</a>）中的形式。新的修正</span>{t}<span class="math-inline">必须与</span>\widetilde{X}<span class="math-inline">的列以及</span>{u}<span class="math-inline">正交。

<p>
当然，修正方程可以通过任何合适的迭代过程近似求解，例如预处理Krylov子空间方法。由于</span>\widetilde{Q}<span class="math-inline">的出现，在使用预处理矩阵</span>A-\theta I<span class="math-inline">时需要谨慎。预处理器的引入可以遵循与单向量Jacobi-Davidson算法相同的原则；参见算法<a href="node144.html#alg:corrit2">4.18</a>的模板。确保迭代求解器的初始向量</span>{t}_0<span class="math-inline">满足正交约束</span>\widetilde{Q}^\ast {t}_0=0<span class="math-inline">。注意，如果在几次Jacobi-Davidson迭代中保持</span>{K}<span class="math-inline">不变，算法<a href="node144.html#alg:corrit2">4.18</a>每步可以节省显著的计算量。在这种情况下，</span>{\widehat{Q}}<span class="math-inline">的列可以从之前的步骤中保存。同样，算法<a href="node144.html#alg:corrit2">4.18</a>中的矩阵</span>{\mathcal M}<span class="math-inline">及其</span>{\mathcal L}{\mathcal U}<span class="math-inline">分解也可以从之前的步骤中更新。

<p>
</dd>
</dl>

<p>
<br>
<a name="alg:corrit2"></a><img
 width="598" height="470" align="BOTTOM" border="0"
 src="img1385.png"
 alt="\begin{algorithm}{Approximate Solution of the
Deflated Jacobi--Davidson HEP Corr...
...(d)} </span>{z}={\widehat{y}}-{\widehat{Q}}\vec{\alpha}$\end{tabbing}}
\end{algorithm}">
<br>

<p>
<hr><!--Navigation Panel-->
<a name="tex2html2912"
  href="node145.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html2906"
  href="node140.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html2902"
  href="node143.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html2908"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html2910"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b>下一节：</b><a name="tex2html2913" href="node145.html">计算内部特征值</a>
<b>上一级：</b><a name="tex2html2907" href="node140.html">重启与收缩</a>
<b>上一节：</b><a name="tex2html2903" href="node143.html">Preconditioning.</a>
  
  
<!--End of Navigation Panel-->
<address>
Susan Blackford
2000-11-20
</address>
</body>
</html>
