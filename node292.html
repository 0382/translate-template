<!DOCTYPE html>

<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
<head>
<title>算法</title>
<meta charset="utf-8">
<meta name="description" content="算法">
<meta name="keywords" content="book, math, eigenvalue, eigenvector, linear algebra, sparse matrix">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var math_displays = document.getElementsByClassName("math-display");
        for (var i = 0; i < math_displays.length; i++) {
            katex.render(math_displays[i].textContent, math_displays[i], { displayMode: true, throwOnError: false });
        }
        var math_inlines = document.getElementsByClassName("math-inline");
        for (var i = 0; i < math_inlines.length; i++) {
            katex.render(math_inlines[i].textContent, math_inlines[i], { displayMode: false, throwOnError: false });
        }
    });
</script>
<style>
    .navigate {
        background-color: #ffffff;
        border: 1px solid black;
        color: black;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 18px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 4px;
    }
    .crossref {
        width: 10pt;
        height: 10pt;
        border: 1px solid black;
        padding: 0;
    }
</style>
</head>

<body >
<!--Navigation Panel-->
<a name="tex2html5229"
  href="node293.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html5223"
  href="node287.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html5217"
  href="node291.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html5225"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html5227"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b>下一节：</b><a name="tex2html5230" href="node293.html">可用的软件</a>
<b>上一级：</b><a name="tex2html5224" href="node287.html">Jacobi-Davidson Method &nbsp;G.&nbsp;Sleijpen and</a>
<b>上一节：</b><a name="tex2html5218" href="node291.html">Restart.</a>
  
  
<br>
<br>
<!--End of Navigation Panel--><h2><a name="SECTION001743000000000000000"></a><a name="ss:JD7-template"></a>
<br>
算法
</h2>

<p>
Jacobi-Davidson算法在算法<a href="node292.html#alg:jdqzhar">8.1</a>中给出。该算法试图计算广义Schur对

<span class="math-inline">((\alpha,\beta),q)</span>，其中比值<span class="math-inline">\beta/\alpha</span>在复平面上最接近指定的目标值<span class="math-inline">\tau</span>。
算法包含重启机制以限制搜索空间的维度，并通过已经收敛的左右Schur向量进行收缩。

<p>

<p></p>
<div align="CENTER">

<p><a name="alg:jdqzhar"></a></p><img
 width="598" height="871" border="0"
 src="img2762.png"
 alt="\begin{figure}\begin{algorithm}{Jacobi--Davidson QZ Method for <span class="math-inline">k_{\max}</span>\ Inter...
...}<span class="math-inline">\ \\
{\rm (38)}\&gt; {\bf end while}
\end{tabbing}}
\end{algorithm}\end{figure}">
</div>
<p></p>

<p>
应用此算法时，我们需要指定一个初始向量</span>v_0<span class="math-inline">，一个容差</span>\epsilon<span class="math-inline">，一个目标值</span>\tau<span class="math-inline">，以及一个数字</span>k_{\max}<span class="math-inline">，它指定应计算多少个接近</span>\tau<span class="math-inline">的本征对。</span>{m}_{\max}<span class="math-inline">的值指定了搜索子空间的最大维度。如果超过此值，则以维度为</span>{m}_{\min}<span class="math-inline">的子空间进行重启。

<p>
完成后，将交付</span>k_{\max}<span class="math-inline">个接近</span>\tau<span class="math-inline">的广义特征值，以及相应的缩减Schur形式</span>AQ=ZR^A<span class="math-inline">，</span>BQ={Z}R^B<span class="math-inline">，其中</span>Q<span class="math-inline">和</span>Z<span class="math-inline">是</span>n<span class="math-inline">乘</span>k_{\max}<span class="math-inline">的正交矩阵，</span>R^A<span class="math-inline">和</span>R^B<span class="math-inline">是</span>k_{\max}<span class="math-inline">乘</span>k_{\max}<span class="math-inline">的上三角矩阵。广义特征值是</span>R^A<span class="math-inline">和</span>R^B<span class="math-inline">的对角线元素。计算形式满足
</span>\Vert A q_{j}- {Z} R^Ae_{j}\Vert _2=O(\epsilon)<span class="math-inline">，

</span>\Vert B q_{j}- {Z} R^Be_{j}\Vert _2=O(\epsilon)<span class="math-inline">，
其中</span>q_j<span class="math-inline">是</span>Q<span class="math-inline">的第</span>j<span class="math-inline">列。

<p>
计算的缩减Schur形式的精度取决于目标值</span>\tau<span class="math-inline">与特征值

</span>(\alpha_j,\beta_j)\equiv(R^A_{j,j},R^B_{j,j})<span class="math-inline">之间的距离。
如果我们忽略机器精度和</span>\epsilon^2<span class="math-inline">阶的项，那么我们有
</span>\Vert A q_j- {Z} R^Ae_j\Vert _2\leq j\gamma_A \epsilon<span class="math-inline">，
       
</span>\Vert B q_j- {Z} R^Be_j\Vert _2\leq j\gamma_B \epsilon<span class="math-inline">，
其中常数
</span>\gamma_A<span class="math-inline">和</span>\gamma_B<span class="math-inline">由
<br><p></p>
<div align="CENTER">


<div class="math-display">\gamma_A\equiv\frac{\vert\mu_0\vert}{\vert\nu_0\alpha_j+\mu_0......frac{\vert\nu_0\vert}{\vert\nu_0\alpha_j+\mu_0\beta_j\vert}.</div>
</div>
<br clear="ALL">
<p></p>
如果
</span>\mu_0/\nu_0=-\tau<span class="math-inline">，如算法步骤(1)中所示，那么
       
</span>\gamma_A=\vert\tau\vert/\vert\alpha_j-\tau\beta_j\vert<span class="math-inline">，
       
</span>\gamma_B=1/\vert\alpha_j-\tau\beta_j\vert<span class="math-inline">。这些值可能很大
如果
</span>\tau\approx \alpha_j/\beta_j<span class="math-inline">。实际上，如果</span>\tau<span class="math-inline">接近检测到的特征值，也能达到</span>\epsilon<span class="math-inline">阶的精度。当使用值
</span>(\mu_0,\nu_0)=(1,\bar\tau)<span class="math-inline">进行额外的细化步骤时，可以保证</span>\epsilon<span class="math-inline">阶的精度。

<p>
现在我们将解释算法的主要连续阶段。
<dl>
<dt><strong>(1)</strong></dt>
<dd>初始化阶段。
标量</span>\nu_0<span class="math-inline">和</span>\mu_0<span class="math-inline">的选择特别有效
如果</span>\tau<span class="math-inline">在谱的内部。
如果</span>\tau<span class="math-inline">是特征值（可以轻松测试），此选择会导致分解失败。

<p>
</dd>
<dt><strong>(4)-(5)</strong></dt>
<dd>新向量</span>t<span class="math-inline">通过修改的Gram-Schmidt方法相对于当前搜索子空间</span>V<span class="math-inline">进行正交化。
同样，向量
</span>w=(\nu_0A+\mu_0B)t<span class="math-inline">相对于当前测试子空间</span>W<span class="math-inline">进行正交化。这两个正交化过程可以通过算法<a href="node138.html#alg:rgs">4.14</a>（第<a href="node138.html#alg:rgs"><button class="crossref"></button></a>页）中的模板替换，以提高数值稳定性。

<p>
我们扩展子空间</span>V<span class="math-inline">，</span>V^A\equiv AV<span class="math-inline">，</span>V^B\equiv BV<span class="math-inline">，以及</span>W<span class="math-inline">。
</span>V<span class="math-inline">表示包含当前搜索子空间基向量</span>v_i<span class="math-inline">作为列的矩阵。其他矩阵以类似明显的方式定义。

<p>
</dd>
<dt><strong>(12)-(13)</strong></dt>
<dd>计算矩阵
</span>M^A\equiv W^\ast A V<span class="math-inline">
和
</span>M^B\equiv W^\ast B V<span class="math-inline">的第</span>{m}<span class="math-inline">行和列。

<p>
注意，标量</span>M_{i,{m}}^B<span class="math-inline">也可以从标量</span>M_{i,{m}}^A<span class="math-inline">以及步骤(10)中</span>w_i^\ast w<span class="math-inline">的正交化常数计算得出。

<p>
</dd>
<dt><strong>(15)</strong></dt>
<dd><p>
可以通过LAPACK中适用于密集矩阵束的合适例程计算</span>{m}<span class="math-inline">乘</span>{m}<span class="math-inline">矩阵对</span>(M^A, M^B)<span class="math-inline">的QZ分解。

<p>
我们选择计算广义Petrov对，这使得算法适合于计算</span>k_{\max}<span class="math-inline">个内部广义特征值

</span>\beta A-\alpha B<span class="math-inline">，其中</span>\alpha/\beta<span class="math-inline">接近指定的</span>\tau<span class="math-inline">。

<p>
有关重新排序广义Schur形式的算法，请参见[<a
 href="node421.html#vand81">448</a>,<a
 href="node421.html#vand82">449</a>,<a
 href="node421.html#fokk96">171</a>]。

<p>
</dd>
<dt><strong>(18)</strong></dt>
<dd>停止准则是在归一化右Schur向量近似残差的范数低于</span>\epsilon<span class="math-inline">时接受广义本征对近似。这意味着我们在计算的广义特征值中接受</span>\epsilon<span class="math-inline">阶的不精确性，以及Schur向量中</span>O({\epsilon})<span class="math-inline">（角度）的不精确性（前提是所关心的特征值是简单的且与其他特征值充分分离）。

<p>
无法保证检测到所有所需特征值；请参见算法<a href="node144.html#alg:jdqr">4.17</a>（第<a href="node144.html#alg:jdqr"><button class="crossref"></button></a>页）的注释(13)。

<p>
</dd>
<dt><strong>(22)</strong></dt>
<dd>在接受一个Petrov对后，我们继续搜索下一个对，剩余的Petrov向量作为初始搜索空间的基。

<p>
</dd>
<dt><strong>(30)</strong></dt>
<dd>当当前特征向量的搜索空间的维度超过</span>{m}_{\max}<span class="math-inline">时，我们进行重启。重启过程以</span>{m}_{\min}<span class="math-inline">个左右Ritz向量为基础，这些Ritz向量对应于最接近目标值</span>\tau<span class="math-inline">的广义Ritz对。

<p>
</dd>
<dt><strong>(36)</strong></dt>
<dd>我们将已锁定的（计算的）右Schur向量收集在</span>{Q}<span class="math-inline">中，矩阵</span>\tilde{Q}<span class="math-inline">是</span>{Q}<span class="math-inline">扩展了当前右Schur特征向量近似</span>{u}<span class="math-inline">。同样，收敛的左Schur向量已被收集在</span>{Z}<span class="math-inline">中，该矩阵扩展了</span>{p}<span class="math-inline">。这样做是为了获得更紧凑的表述；算法<a href="node292.html#alg:jdqzhar">8.1</a>步骤(37)中的修正方程等价于方程(<a href="node288.html#eq:JD7-CE">8.13</a>)中关于收缩对(<a href="node290.html#eq:JD7-defl">8.15</a>)的修正方程。新修正</span>{t}<span class="math-inline">必须与</span>{Q}<span class="math-inline">的列以及</span>{u}<span class="math-inline">正交。

<p>
当然，修正方程可以通过任何合适的进程求解，例如，设计用于求解非对称系统的预处理Krylov子空间方法。然而，由于不同的投影，我们总是需要一个预处理器（如果没有任何其他可用，则可能是恒等算子），该预处理器通过相同的斜投影进行收缩，以便我们在

</span>\widetilde{Q}^\perp<span class="math-inline">和自身之间获得映射。
由于</span>\widetilde{Q}<span class="math-inline">和</span>\widetilde{Z}<span class="math-inline">的出现，必须谨慎使用矩阵

</span>\eta A -\zeta B<span class="math-inline">的预处理器。
预处理器的包含可以按照算法<a href="node292.html#alg:corritgen">8.2</a>进行。确保迭代求解器的初始向量</span>t_0<span class="math-inline">满足正交约束

</span>\widetilde Q^\ast t_0=0<span class="math-inline">。请注意，如果在几次Jacobi-Davidson迭代中保持</span>{K}<span class="math-inline">不变，算法<a href="node292.html#alg:corritgen">8.2</a>每步可以节省显著的计算量。在这种情况下，可以从先前步骤中保存</span>\widehat{Z}<span class="math-inline">的列。同样，矩阵</span>{\mathcal M}<span class="math-inline">及其

</span>{\mathcal L}{\mathcal U}<span class="math-inline">分解也可以从先前步骤更新。

<p>
没有必要非常精确地求解修正方程。一种常用于不精确牛顿方法[<a
 href="node421.html#dees83">113</a>]的策略在这里也工作得很好：
随着Jacobi-Davidson迭代步骤增加精度，例如，在第</span>\ell<span class="math-inline">次Jacobi-Davidson迭代中以</span>2^{-\ell}<span class="math-inline">的残差减少求解修正方程（当检测到Schur向量时，</span>\ell<span class="math-inline">重置为0）。

<p>
特别是在最初的几个初始步骤中，近似特征值</span>\theta<span class="math-inline">可能非常不准确，此时精确求解修正方程没有意义。在这个阶段，暂时将</span>\theta<span class="math-inline">替换为</span>\tau<span class="math-inline">或取</span>{t}=-r<span class="math-inline">以扩展搜索子空间可能更有效[<a
 href="node421.html#mosc86">335</a>,<a
 href="node421.html#fosv98">172</a>]。
</dd>
</dl>

<p>
有关此方法的完整理论背景以及Schur向量的收缩技术细节，请参见[<a
 href="node421.html#fosv98">172</a>]。

<p>

<p></p>
<div align="CENTER">

<p><a name="alg:corritgen"></a></p><img
 width="598" height="470" border="0"
 src="img2798.png"
 alt="\begin{figure}\begin{algorithm}{Approximate Solution of the
Deflated Jacobi--Dav...
...{Z}\vec{\alpha}</span>\end{tabbing}}
\end{algorithm}\vspace*{-9pt}%% help
\end{figure}">
</div>
<p></p>

<p>
<hr><!--Navigation Panel-->
<a name="tex2html5229"
  href="node293.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html5223"
  href="node287.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html5217"
  href="node291.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html5225"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html5227"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b>下一节：</b><a name="tex2html5230" href="node293.html">可用的软件</a>
<b>上一级：</b><a name="tex2html5224" href="node287.html">Jacobi-Davidson Method &nbsp;G.&nbsp;Sleijpen and</a>
<b>上一节：</b><a name="tex2html5218" href="node291.html">Restart.</a>
  
  
<!--End of Navigation Panel-->
<address>
Susan Blackford
2000-11-20
</address>
</body>
</html>
