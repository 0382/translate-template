<!DOCTYPE html>

<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
<head>
<title>与对称Lanczos的关系</title>
<meta charset="utf-8">
<meta name="description" content="与对称Lanczos的关系">
<meta name="keywords" content="book, math, eigenvalue, eigenvector, linear algebra, sparse matrix">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var math_displays = document.getElementsByClassName("math-display");
        for (var i = 0; i < math_displays.length; i++) {
            katex.render(math_displays[i].textContent, math_displays[i], { displayMode: true, throwOnError: false });
        }
        var math_inlines = document.getElementsByClassName("math-inline");
        for (var i = 0; i < math_inlines.length; i++) {
            katex.render(math_inlines[i].textContent, math_inlines[i], { displayMode: false, throwOnError: false });
        }
    });
</script>
<style>
    .navigate {
        background-color: #ffffff;
        border: 1px solid black;
        color: black;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 18px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 4px;
    }
    .crossref {
        width: 10pt;
        height: 10pt;
        border: 1px solid black;
        padding: 0;
    }
</style>
</head>

<body >
<!--Navigation Panel-->
<a name="tex2html3757"
  href="node200.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html3751"
  href="node197.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html3747"
  href="node198.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html3753"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html3755"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b>下一节：</b><a name="tex2html3758" href="node200.html">可用的软件</a>
<b>上一级：</b><a name="tex2html3752" href="node197.html">Golub-Kahan-Lanczos 方法</a>
<b>上一节：</b><a name="tex2html3748" href="node198.html">与对称Lanczos的关系</a>
<br>
<br>
<!--End of Navigation Panel--><h4><a name="SECTION001533020000000000000">
与对称Lanczos方法的关系。</a>
</h4>

从方程(<a href="node198.html#lansvdeq1">6.7</a>)、(<a href="node198.html#lansvdeq2">6.8</a>)和
(<a href="node198.html#uvorth">6.9</a>)中，我们有

<div class="math-display">A^{\ast} A V_k = V_k B^*_k B_k + \alpha_k \beta_{k}v_{k+1}e^*_k.</div>

我们注意到<span class="math-inline">B^*_k B_k</span>是对称的且三对角的，因为<span class="math-inline">B_k</span>是双对角的。
与方程(<a href="node103.html#herm-recursion">4.10</a>)比较，我们可以看到
算法(<a href="node198.html#gklmethod">6.1</a>)
计算的信息与
应用于厄米矩阵<span class="math-inline">A^{\ast} A</span>的Lanczos方法（算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)）相同。
相反，如果我们对<span class="math-inline">A^* A</span>应用Lanczos方法得到一个三对角矩阵
<span class="math-inline">T_k = B^*_k B_k</span>，那么<span class="math-inline">B_k</span>可以通过取<span class="math-inline">T_k</span>的上三角Cholesky因子得到。

<p>
类似地，我们得到

<div class="math-display">AA^* U_k = U_k B_k B_k^* + \beta_k (A v_{k+1}) e_k^*.</div>

同样，<span class="math-inline">B_k B_k^*</span>是对称的且三对角的。
所以再次与方程(<a href="node103.html#herm-recursion">4.10</a>)比较，我们可以看到
算法(<a href="node198.html#gklmethod">6.1</a>)
计算的信息与
应用于厄米矩阵<span class="math-inline">AA^*</span>的Lanczos方法（算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)）相同。
相反，如果我们对<span class="math-inline">AA^*</span>应用Lanczos方法得到一个三对角矩阵
<span class="math-inline">T_k = B_k B_k^*</span>，那么<span class="math-inline">B_k</span>可以通过取<span class="math-inline">JT_kJ</span>的上三角Cholesky因子<span class="math-inline">B'</span>得到，其中<span class="math-inline">J</span>是
其列按逆序排列的单位矩阵
（因此<span class="math-inline">JT_kJ</span>是通过反转<span class="math-inline">T_k</span>的行和列的顺序得到的），然后<span class="math-inline">B_k = JB'J</span>。

<p>
最后，假设我们使用特殊的起始向量

<div class="math-display">z_1 = \begin{bmatrix} 0 \\ v_1 \end{bmatrix}</div>

对<span class="math-inline">H(A)</span>应用Lanczos方法（算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)）
生成Lanczos向量<span class="math-inline">z_2, z_3,\ldots.</span>
算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)的第一步产生

<div class="math-display">
\begin{aligned}
r &= H(A)z_1 = \begin{bmatrix} Av_1 \\ 0\end{bmatrix}, \\
\hat{\alpha}_1 &= r^*z_1 = 0, \\
r &= r - 0*z_1, \\
\hat{\beta}_1 &= \Vert r \Vert_2, \\
z_2 &= r/\hat{\beta}_1, \\
  &= \begin{bmatrix} u_1 \\ 0 \end{bmatrix}.
\end{aligned}
</div>
其中 <span class="math-inline">u_1</span> 在算法(<a href="node198.html#gklmethod">6.1</a>)中的第(5)行计算得到。

<p>
算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)的下一步产生

<div class="math-display">
\begin{aligned}
r &= H(A)z_2 = \begin{bmatrix} 0 \\ A^*u_1\end{bmatrix}, \\
\hat{\alpha}_2 &= r^*z_2 = 0, \\
r &= r - 0*z_2 - \hat{\beta}_1 z_1 = \begin{bmatrix}0 \\ Au_1\end{bmatrix} - \begin{bmatrix}0 \\ \hat{\beta}_1 v_1\end{bmatrix}, \\
\hat{\beta}_2 &= \Vert r \Vert_2, \\
z_3 &= r/\hat{\beta}_2, \\
  &= \begin{bmatrix} 0 \\ v_2 \end{bmatrix}.
\end{aligned}
</div>
其中 <span class="math-inline">v_2</span> 在算法(<a href="node198.html#gklmethod">6.1</a>)中的第(8)行计算得到。

<p>
继续这种方式，我们可以看到算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)的两步计算的信息
与算法(<a href="node198.html#gklmethod">6.1</a>)的一步相同：

<div class="math-display">z_{2i-1} = \begin{bmatrix} 0 \\ v_i \end{bmatrix}\; \; {\rm and} \; \;z_{2i} = \begin{bmatrix} u_i \\ 0 \end{bmatrix}.</div>

然而，算法(<a href="node104.html#Symmetric_Lanczos">4.6</a>)进行了两倍的矩阵-向量乘法
通过<span class="math-inline">A</span>和<span class="math-inline">A^*</span>与算法(<a href="node198.html#gklmethod">6.1</a>)
（其中一半是通过零向量的乘法），因此
算法(<a href="node198.html#gklmethod">6.1</a>)通常会使用一半的时间和空间。
相反，如果对<span class="math-inline">H(A)</span>应用Lanczos方法得到一个
三对角矩阵<span class="math-inline">T_k</span>，那么<span class="math-inline">T_k</span>的对角线上会有零，
非对角线元素将与<span class="math-inline">B_k</span>（从方程(<a href="node198.html#uav">6.4</a>)的符号）的非零元素相同：

<div class="math-display">T_{2k} = \begin{bmatrix}
0 & \alpha_1 & & & & & \\
\alpha_1 & 0 & \beta_1 & & & \\
& \beta_1 & 0 & \alpha_2 & & \\
& & \alpha_2 & 0 & \beta_2 & \\
& & & \beta_2 & 0 & \ddots \\
& & & & \ddots & \ddots & \alpha_k \\
& & & & & \alpha_k & 0
\end{bmatrix}.</div>

由于这些等价性，第&#167;<a href="node103.html#sec:lan">4.4</a>节中Lanczos的所有算法变体
和收敛性质都适用于
算法(<a href="node198.html#gklmethod">6.1</a>)。

<p>
<hr><!--Navigation Panel-->
<a name="tex2html3757"
  href="node200.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html3751"
  href="node197.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html3747"
  href="node198.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html3753"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html3755"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b>下一节：</b><a name="tex2html3758" href="node200.html">可用的软件</a>
<b>上一级：</b><a name="tex2html3752" href="node197.html">Golub-Kahan-Lanczos 方法</a>
<b>上一节：</b><a name="tex2html3748" href="node198.html">与对称Lanczos的关系</a>
<!--End of Navigation Panel-->
<address>
Susan Blackford
2000-11-20
</address>
</body>
</html>
