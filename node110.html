<!DOCTYPE html>

<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
<head>
<title>Selective Reorthogonalization.</title>
<meta name="description" content="Selective Reorthogonalization.">
<meta name="keywords" content="book">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">

<meta charset="utf-8">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var math_displays = document.getElementsByClassName("math-display");
        for (var i = 0; i < math_displays.length; i++) {
            katex.render(math_displays[i].textContent, math_displays[i], { displayMode: true, throwOnError: false });
        }
        var math_inlines = document.getElementsByClassName("math-inline");
        for (var i = 0; i < math_inlines.length; i++) {
            katex.render(math_inlines[i].textContent, math_inlines[i], { displayMode: false, throwOnError: false });
        }
    });
</script>
<style>
    .navigate {
        background-color: #f0f0f0;
        border: 1px;
        color: black;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 8px;
    }
</style>
<link rel="next" href="node111.html">
<link rel="previous" href="node109.html">
<link rel="up" href="node108.html">
<link rel="next" href="node111.html">
</head>

<body>
<!--Navigation Panel-->
<a name="tex2html2412"
  href="node111.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html2406"
  href="node108.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html2400"
  href="node109.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html2408"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html2410"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b> Next:</b> <a name="tex2html2413"
  href="node111.html">Local Reorthogonalization and Detecting</a>
<b> Up:</b> <a name="tex2html2407"
  href="node108.html">Reorthogonalization</a>
<b> Previous:</b> <a name="tex2html2401"
  href="node109.html">Full Reorthogonalization.</a>
 &nbsp <b>  <a name="tex2html2409"
  href="node5.html">Contents</a></b> 
 &nbsp <b>  <a name="tex2html2411"
  href="node422.html">Index</a></b> 
<br>
<br>
<!--End of Navigation Panel--><h4><a name="SECTION001344020000000000000">
选择性再正交化</a>
</h4>
随着基的大小 <span class="math-inline">j</span> 增长，完全再正交化将需要大量的算术工作，我们寻求一种更经济的方案。可以证明，只要基是<i>半正交</i>的，即正交到机器精度的二分之一，<br>
<div align="right">

<table width="100%" align="center">
<tr valign="middle"><td align="center" NOWRAP><a name="semiorthogonal"></a><div class="math-display">W_{j}=V^{\ast}_jv_j=I_{j}+E\,, \quad \Vert E\Vert &lt; \sqrt{\eps}\,.</div></td>
<td width=10 align="right">
(32)</td></tr>
</table>
<br clear="ALL"></div><p></p>

<p>
读者可参考Simon的调查[<a href="node421.html#simo84b">402</a>]以获得这些问题的详细讨论。证明显示，如果通过具有半正交基 <span class="math-inline">V_j</span> 的Lanczos算法计算三对角矩阵 <span class="math-inline">T</span>（<a href="node110.html#semiorthogonal">4.18</a>），那么 <span class="math-inline">T</span> 是 <span class="math-inline">A</span> 在计算基 <span class="math-inline">V_j</span> 所张成的子空间上的完全精确投影，
<br><p></p>
<div align="center">
<div class="math-display">T_{j}=N_j^{\ast} AN_j+G\,, \quad \Vert G\Vert = O(\eps\Vert A\Vert)\,.</div>
</div>
<br clear="ALL">
<p></p>
这里 <span class="math-inline">N_j</span> 是 <span class="math-inline">V_j</span> 所张成的子空间的一个正交基。即使 <span class="math-inline">N_j</span> 不是显式已知的，我们也知道 <span class="math-inline">T_j</span> 的特征值是 <span class="math-inline">A</span> 的特征值的精确近似。

<p>
确保计算基是半正交的一种方法是使用Paige导出的递归关系来监控在早期步骤中正交性的损失如何传播到后续步骤，并在该递归关系指示超过 <span class="math-inline">\sqrt{\eps}</span> 的阈值时进行再正交化。递归关系涉及乘积矩阵 <span class="math-inline">W_{j}</span> 的连续元素 <span class="math-inline">\omega_{j,k}</span>（<a href="node110.html#semiorthogonal">4.18</a>），并从基本递归关系（<a href="node103.html#herm-recursion">4.10</a>）以以下方式导出。

<p>
首先我们注意到计算向量 <span class="math-inline">v_{j+1}</span> 满足（<a href="node103.html#herm-recursion">4.10</a>）：
<br><p></p>
<div align="center">
<div class="math-display">\beta_jv_{j+1}=Av_j-\alpha_j v_j - \beta_{j-1}v_{j-1}+f_j,</div>
</div>
<br clear="ALL">
<p></p>
其中 <span class="math-inline">f_j</span> 是舍入误差向量。为了得到乘积矩阵 <span class="math-inline">W_{j}</span> 的元素 <span class="math-inline">\omega_{j,k}</span>（<a href="node110.html#semiorthogonal">4.18</a>），我们用 <span class="math-inline">v_k^{\ast}</span> 预乘这个方程并得到
<br><p></p>
<div align="center">
<div class="math-display">\beta_j\omega_{j+1,k}=v_k^{\ast}Av_j-\alpha_j \omega_{j,k} - \beta_{j-1}\omega_{j-1,k}+v_k^{\ast}f_j\,.</div>
</div>
<br clear="ALL">
<p></p>
交换索引 <span class="math-inline">j</span> 和 <span class="math-inline">k</span> 的乘法给出
<br><p></p>
<div align="center">
<div class="math-display">\beta_k\omega_{j,k+1}=v_j^{\ast}Av_k-\alpha_k \omega_{j,k} - \beta_{k-1}\omega_{j,k-1}+v_j^{\ast}f_k\,,</div>
</div>
<br clear="ALL">
<p></p>
减去这两个方程得到
<br>
<div align="right">
<table width="100%" align="center">
<tr valign="middle"><td align="center" NOWRAP><a name="w-recursion"></a><div class="math-display">\beta_j\omega_{j+1,k}=\beta_k\omega_{j,k+1}+(\alpha_k-\alpha_j)\omega_{j,k}+\beta_{k-1}\omega_{j-1,k}-v_j^{\ast}f_k+v_k^{\ast}f_j.\hspace*{6pt}</div></td>
<td width=10 align="right">
(33)</td></tr>
</table>
<br clear="ALL"></div><p></p>
注意涉及 <span class="math-inline">A</span> 的项会抵消，因为对于Hermitian矩阵 <span class="math-inline">A</span>，有 <span class="math-inline">v_k^{\ast}av_j=v_j^{\ast}Av_k</span>。

<p>
我们使用这个递归来逐行填充对称矩阵 <span class="math-inline">W</span> 的下三角部分。对角元素 <span class="math-inline">\omega_{k,k}=1</span> 和最靠近对角线上下的元素 <span class="math-inline">\omega_{k-1,k}=\omega_{k,k-1}=O(\eps)</span> 在舍入误差水平上，由于对称性和显式正交化。这为递归关系（<a href="node110.html#w-recursion">4.19</a>）提供了起始值。我们估计（<a href="node110.html#w-recursion">4.19</a>）中最后两项之和的绝对值为 <span class="math-inline">2\eps\Vert A\Vert</span>，并根据对 <span class="math-inline">A</span> 范数的适当猜测，将这些值（也在舍入误差水平上）输入递归，选择符号使得新的 <span class="math-inline">\vert\omega_{j+1,k}\vert</span> 的绝对值最大化，
<br><p></p>
<div align="center">
<div class="math-display">\tilde{\omega}=\beta_k\omega_{j,k+1}+(\alpha_k-\alpha_j)\omega_{j,k}+\beta_{k-1}\omega_{j,k-1}-\beta_{j-1}\omega_{j-1,k},</div>
</div>
<br clear="ALL">
<p></p>
<br><p></p>
<div align="center">
<div class="math-display">\omega_{j+1,k}=(\tilde{\omega}+\mathrm{sign}(\tilde{\omega})2\eps\Vert A\Vert)/\beta_j.</div>
</div>
<br clear="ALL">
<p></p>

<p>
一旦某个元素 <span class="math-inline">\omega_{j+1,k}</span> 超过 <span class="math-inline">\sqrt{\eps}</span> 大小的阈值，我们就将当前的两个向量 <span class="math-inline">v_{j}</span> 和 <span class="math-inline">v_{j+1}</span> 对所有先前的向量 <span class="math-inline">v_k\,,\, k=1,\dots,j</span> 进行正交化，并将相应的 <span class="math-inline">\omega_{j,k}</span> 和 <span class="math-inline">\omega_{j+1,k}</span> 降至舍入误差水平。我们需要正交化两个向量，因为在Lanczos方法中有三项递归关系，因此在 <span class="math-inline">\omega</span> 递归（<a href="node110.html#w-recursion">4.19</a>）中也是如此。不需要存储超过矩阵 <span class="math-inline">W</span> 的 <span class="math-inline">\omega</span> 估计值的两行，即 <span class="math-inline">j-1</span> 和 <span class="math-inline">j</span>。

<p>
上述是[<a href="node421.html#simo84b">402</a>]中描述的技术之一。还有一种方法仅对那些 <span class="math-inline">\omega_{j+1,k}</span> 超过阈值的向量 <span class="math-inline">v_k</span> 进行显式正交化。这就是Simon[<a href="node421.html#simo84b">402</a>]所称的<i>部分</i>再正交化，但这里描述的变体，即<i>周期性</i>再正交化，由Grcar[<a href="node421.html#grcar81">204</a>]首次描述，实现起来更简单，并且可以使用Level 2 BLAS操作。

<p>
<hr><!--Navigation Panel-->
<a name="tex2html2412"
  href="node111.html">
<button class="navigate">下一节</button></a> 
<a name="tex2html2406"
  href="node108.html">
<button class="navigate">上一级</button></a> 
<a name="tex2html2400"
  href="node109.html">
<button class="navigate">上一节</button></a> 
<a name="tex2html2408"
  href="node5.html">
<button class="navigate">目录</button></a> 
<a name="tex2html2410"
  href="node422.html">
<button class="navigate">索引</button></a> 
<br>
<b> Next:</b> <a name="tex2html2413"
  href="node111.html">Local Reorthogonalization and Detecting</a>
<b> Up:</b> <a name="tex2html2407"
  href="node108.html">Reorthogonalization</a>
<b> Previous:</b> <a name="tex2html2401"
  href="node109.html">Full Reorthogonalization.</a>
 &nbsp <b>  <a name="tex2html2409"
  href="node5.html">Contents</a></b> 
 &nbsp <b>  <a name="tex2html2411"
  href="node422.html">Index</a></b> 
<!--End of Navigation Panel-->
<address>
Susan Blackford
2000-11-20
</address>
</body>
</html>
